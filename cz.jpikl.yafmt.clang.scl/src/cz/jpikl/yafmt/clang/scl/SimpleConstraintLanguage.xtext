// Name of the main class and its containing package.
// org.eclipse.xtext.common.Terminals contains definition of basic terminal
// symbols (like ID) and hidden tokens (white-spaces).
grammar cz.jpikl.yafmt.clang.scl.SimpleConstraintLanguage 
   with org.eclipse.xtext.common.Terminals

// model is the name of the generated package (cz.jpikl.yafmt.clang.scl.model)
// It is also prefix for generated EMF model factory and model package.
generate model "https://bitbucket.org/jpikl/yafmt/clang/scl"

// Unassigned rule call
// 
// It simply call ContextualExpression rule.
// The return type is Expression (abstract class for all kinds of expressions).
Expression:
    ContextualExpression;	
    
// Uses simple action: {ExplicitReturnType} memberVariable=value.
//
// If there is 'context' token at input, instance of ContextualExpression is returned. 
// Value contains the parsed ID and expression contains the result of Implication rule.
// Otherwise (no 'context' found), the result of Implication rule is returned. 
ContextualExpression returns Expression:
    'context' {ContextualExpression} contextId=ID ':' expression=Implication | Implication;

Implication returns Expression:
    Disjunction ({Implication.leftPart=current} ('implies' | 'requires' | '->' | '=>') rightPart=Disjunction)?;
    
// Uses assigned action: {ExplicitReturnType.memberVariable=value}.
// This particular case is also called tree rewrite action.
//
// If there is no 'or' token, the rule simply returns result of the only one ExclusiveDisjunction rule.
//
// Otherwise, instance of Disjunction is returned. Parts array contains results of parsed ExclusiveDisjunction 
// rules. The result of the first one ExclusiveDisjunction (current keyword) was in that case added 
// to the parts array. Current then became the resulting Disjunction.
//    Disjunction disjunction = new Disjunction();
//    disjunction.getParts().add(current);
//    current = disjunction;
Disjunction returns Expression:
    ExclusiveDisjunction ({Disjunction.parts+=current} ('or' | '|') parts+=ExclusiveDisjunction)*;

ExclusiveDisjunction returns Expression:
    Conjunction ({ExclusiveDisjunction.parts+=current} ('xor' | '^') parts+=Conjunction)*;
	
Conjunction returns Expression:
    Negation ({Conjunction.parts+=current} ('and' | '&') parts+=Negation)*;	

Negation returns Expression:
    PrimaryExpression | ('not' | '!') {Negation} expression=PrimaryExpression;
	
PrimaryExpression returns Expression:
    {PrimaryExpression} featureId=ID | '(' Expression ')';
