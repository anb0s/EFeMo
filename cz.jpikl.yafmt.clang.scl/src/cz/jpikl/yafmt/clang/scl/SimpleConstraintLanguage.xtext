// Name of the main class and its containing package.
// org.eclipse.xtext.common.Terminals contains definition of basic terminal
// symbols (like ID) and hidden tokens (white-spaces).
grammar cz.jpikl.yafmt.clang.scl.SimpleConstraintLanguage 
   with org.eclipse.xtext.common.Terminals

// Ast (Abstract Syntax Tree) is the name of the generated package (cz.jpikl.yafmt.clang.scl.ast)
// It is also prefix for generated EMF model factory and model package.   
generate ast "https://bitbucket.org/jpikl/yafmt/clang/scl"

// Uses unassigned rule call.
//
// The return type is Expression (abstract class for all kinds of expressions).
// It is returned the result of ContextualExpression or Implication rule. 
Expression:
    ContextualExpression | Implication;	
    
ContextualExpression returns Expression:
    'context' context=ID ':' expression=Implication;

Implication returns Expression:
    Disjunction ({Implication.leftPart=current} ('implies' | 'requires' | '->' | '=>') rightPart=Disjunction)?;
    
// Uses assigned action: {ExplicitReturnType.memberVariable=value}.
// This particular case is also called tree rewrite action.
//
// If there is no 'or' token, the rule simply returns result of the only one ExclusiveDisjunction rule.
//
// Otherwise, instance of Disjunction is returned. Parts array contains results of parsed ExclusiveDisjunction 
// rules. The result of the first one ExclusiveDisjunction (current keyword) was in that case added 
// to the parts array. Current then became the resulting Disjunction.
//    Disjunction disjunction = new Disjunction();
//    disjunction.getParts().add(current);
//    current = disjunction;
Disjunction returns Expression:
    ExclusiveDisjunction ({Disjunction.parts+=current} ('or' | '|') parts+=ExclusiveDisjunction)*;

ExclusiveDisjunction returns Expression:
    Conjunction ({ExclusiveDisjunction.parts+=current} ('xor' | '^') parts+=Conjunction)*;
	
Conjunction returns Expression:
    Negation ({Conjunction.parts+=current} ('and' | '&') parts+=Negation)*;	

Negation returns Expression:
    PrimaryExpression | ('not' | '!') {Negation} expression=PrimaryExpression;
	
// Uses simple action: {ExplicitReturnType} memberVariable=value.
//
// If there is an ID token, instance of FeatureId is returned. Value member contains the parsed ID.
// Otherwise (there is an expression inside brackets), the result of Implication rule is returned. 
PrimaryExpression returns Expression:
    {FeatureId} value=ID | '(' Implication ')';
